import os
import json
import logging
import base64
from datetime import datetime
import asyncio
import aiohttp
from sqlalchemy.orm import joinedload
from flask import Blueprint, render_template, request, jsonify
from sqlalchemy import func
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

# Modeller
from models import db, Product, RafUrun, CentralStock

# Trendyol API bilgileri
try:
    from trendyol_api import API_KEY, API_SECRET, SUPPLIER_ID, BASE_URL
except ImportError:
    API_KEY, API_SECRET, SUPPLIER_ID, BASE_URL = None, None, None, "https://api.trendyol.com/sapigw/"

# --- Loglama ---
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Blueprint ve Rate Limit ---
stock_management_bp = Blueprint('stock_management', __name__)
limiter = Limiter(key_func=get_remote_address,
                  default_limits=["200 per day", "50 per hour"])

# Trendyol‚Äôa tek seferde g√∂nderilecek √ºr√ºn sayƒ±sƒ±
BATCH_SIZE = 100


# -------------------------------
# Yardƒ±mcƒ±: Hatalƒ± barkodlarƒ± dosyaya yaz
# -------------------------------
def log_failed_items(failed_items, reason=""):
    try:
        log_dir = "logs/failed_updates"
        os.makedirs(log_dir, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filepath = f"{log_dir}/failed_{timestamp}.json"
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump({"timestamp": timestamp,
                       "reason": reason,
                       "items": failed_items}, f, indent=2, ensure_ascii=False)
        logger.info("%s hatalƒ± barkod loglandƒ±: %s", len(failed_items), filepath)
    except Exception as e:
        logger.error("Hatalƒ± √ºr√ºnleri loglarken hata: %s", e)


# -------------------------------
# Trendyol STOCK-ONLY push (PUT stock-quantity)
# -------------------------------
async def send_trendyol_stock_only_async(items):
    """
    items: [{"barcode": "...", "quantity": int}]
    Trendyol stock-quantity endpoint (sadece stok).
    """
    if not all([API_KEY, API_SECRET, SUPPLIER_ID]):
        logger.error("Trendyol API bilgileri eksik. Stok push iptal.")
        return {"general_error": "API creds missing"}

    # Base URL sapigw; sonuna suppliers/... eklenir
    url = f"{BASE_URL}suppliers/{SUPPLIER_ID}/products/stock-quantity"
    auth = base64.b64encode(f"{API_KEY}:{API_SECRET}".encode("utf-8")).decode("utf-8")
    headers = {
        "Authorization": f"Basic {auth}",
        "Content-Type": "application/json",
        "User-Agent": f"GulluAyakkabi-StockSync/{SUPPLIER_ID}"
    }

    # Temizle ve negatifleri 0‚Äôa sabitle
    cleaned = []
    for it in items:
        bc = (it.get("barcode") or "").strip()
        if not bc:
            continue
        try:
            q = int(it.get("quantity", 0))
        except (TypeError, ValueError):
            q = 0
        if q < 0:
            q = 0
        cleaned.append({"barcode": bc, "quantity": q})

    if not cleaned:
        logger.info("Push edilecek stok yok.")
        return {}

    batches = [cleaned[i:i + BATCH_SIZE] for i in range(0, len(cleaned), BATCH_SIZE)]
    errors = {}

    async with aiohttp.ClientSession(headers=headers) as session:
        for idx, batch in enumerate(batches, start=1):
            # Rate limit nazikliƒüi
            if idx > 1:
                await asyncio.sleep(0.5)
            payload = {"items": batch}
            try:
                async with session.put(url, json=payload, timeout=60) as resp:
                    text = await resp.text()
                    logger.info("[STOCK %d/%d] %s %s", idx, len(batches), resp.status, text[:200])
                    if resp.status not in (200, 202):
                        for it in batch:
                            errors[it["barcode"]] = f"http {resp.status}"
            except Exception as e:
                logger.error("Batch %d exception: %s", idx, e, exc_info=True)
                for it in batch:
                    errors[it["barcode"]] = f"exc {str(e)[:120]}"

    if errors:
        log_failed_items(list(errors.keys()), "stock-quantity errors")
    return errors


# Fire-and-forget helper (Flask senkron baƒülamda async tetikleme)
def _spawn_async(coro):
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(coro)
    except RuntimeError:
        asyncio.run(coro)


# -------------------------------
# HTML Sayfasƒ±
# -------------------------------
@stock_management_bp.route('/stock-addition', methods=['GET'])
def stock_addition_page():
    return render_template('stock_addition.html')


# -------------------------------
# Barkod detay API
# -------------------------------
@stock_management_bp.route('/api/get-product-details-by-barcode/<string:barcode>', methods=['GET'])
@limiter.limit("120/minute")
def get_product_details(barcode):
    try:
        product = Product.query.filter(func.lower(Product.barcode) == barcode.lower()).first()
        cs = CentralStock.query.get(barcode)

        if not product:
            return jsonify(success=False, message="√úr√ºn bulunamadƒ±"), 404

        image_url = 'https://placehold.co/80x80'
        if product.images:
            try:
                image_list = json.loads(product.images)
                if image_list and isinstance(image_list, list):
                    image_url = image_list[0]
            except (json.JSONDecodeError, TypeError):
                image_url = product.images

        return jsonify(success=True, product={
            "barcode": product.barcode,
            "product_main_id": product.product_main_id,
            "color": product.color,
            "size": product.size,
            "quantity": (cs.qty if cs else 0),
            "image_url": image_url
        })
    except Exception as e:
        logger.error("√úr√ºn detayƒ± alƒ±nƒ±rken hata (barkod: %s): %s", barcode, e, exc_info=True)
        return jsonify(success=False, message="Sunucu hatasƒ±."), 500


# -------------------------------
# Stok ekleme/g√ºncelleme (ANA ENDPOINT)
# -------------------------------
@stock_management_bp.route('/stock-addition', methods=['POST'])
@limiter.limit("60/minute")
def handle_stock_update_from_frontend():
    """
    - 'add': Se√ßilen rafa √ºr√ºn ekler, CentralStock'u artƒ±rƒ±r.
    - 'renew': Se√ßilen raftaki T√úM √ºr√ºnleri siler, CentralStock'u d√º≈ü√ºr√ºr,
               ardƒ±ndan SADECE yeni gelen √ºr√ºnleri rafa ekler ve CentralStock'u artƒ±rƒ±r.
               (Rafƒ± sƒ±fƒ±rdan kurar)
    - ‚ùå Trendyol'a herhangi bir push YAPMAZ.
    """
    data = request.get_json(silent=True) or {}
    items = data.get('items', [])
    update_type = data.get('updateType')
    raf_kodu = (data.get('raf_kodu') or '').strip()
    
    # üîß "=" karakterini "-" ile deƒüi≈ütir (telefonlardan kaynaklanƒ±yor)
    raf_kodu = raf_kodu.replace('=', '-')
    
    logger.info(f"üîπ Stok ekleme isteƒüi alƒ±ndƒ±: Raf={raf_kodu}, Mod={update_type}, √úr√ºn Sayƒ±sƒ±={len(items)}")

    if not raf_kodu:
        logger.error("‚ùå Raf kodu bo≈ü geldi!")
        return jsonify(success=False, message="Raf kodu zorunludur."), 400
    if update_type not in ('add', 'renew'):
        logger.error(f"‚ùå Ge√ßersiz i≈ülem tipi: {update_type}")
        return jsonify(success=False, message="updateType 'add' veya 'renew' olmalƒ±."), 400
    if not items and update_type == 'add': # 'renew' bo≈ü liste ile rafƒ± temizleyebilir
         logger.warning(f"‚ö†Ô∏è ƒ∞≈ülenecek √ºr√ºn yok (mod: {update_type})")
         return jsonify(success=False, message="ƒ∞≈ülenecek √ºr√ºn yok."), 400

    errors = {}
    results = []

    try:
        with db.session.begin():  # Tek transaction
            logger.info(f"üì¶ Transaction ba≈ülatƒ±ldƒ± - Raf: {raf_kodu}")
            
            # Gelen √ºr√ºnlerin barkodlarƒ±nƒ± ve Product tablosundaki varlƒ±klarƒ±nƒ± kontrol et
            barcode_set = [it.get('barcode') for it in items if it.get('barcode')]
            valid_products = {}
            if barcode_set:
                logger.info(f"üîç {len(barcode_set)} barkod i√ßin Product tablosunda kontrol yapƒ±lƒ±yor...")
                existing = Product.query.filter(func.lower(Product.barcode).in_([b.lower() for b in barcode_set])).all()
                valid_products = {p.barcode.lower(): True for p in existing}
                logger.info(f"‚úÖ Product tablosunda {len(valid_products)} √ºr√ºn bulundu.")
                
                # Bulunamayan √ºr√ºnleri logla
                missing_barcodes = [bc for bc in barcode_set if bc.lower() not in valid_products]
                if missing_barcodes:
                    logger.warning(f"‚ö†Ô∏è Product tablosunda BULUNAMAYAN barkodlar ({len(missing_barcodes)}): {', '.join(missing_barcodes[:10])}{'...' if len(missing_barcodes) > 10 else ''}")

            # --- 'RENEW' (YENƒ∞LE) MANTIƒûI ---
            if update_type == 'renew':
                logger.info(f"üîÑ '{raf_kodu}' rafƒ± i√ßin YENƒ∞LEME i≈ülemi ba≈ülatƒ±ldƒ±.")
                # 1. Bu raftaki T√úM mevcut √ºr√ºnleri bul
                raftaki_eski_urunler = RafUrun.query.filter_by(raf_kodu=raf_kodu).all()
                logger.info(f"üìã Rafta mevcut {len(raftaki_eski_urunler)} kayƒ±t bulundu.")

                # 2. Bu √ºr√ºnlerin stoklarƒ±nƒ± merkezi stoktan d√º≈ü
                if raftaki_eski_urunler:
                    logger.info(f"‚¨áÔ∏è CentralStock'tan d√º≈ü√ºlen √ºr√ºnler:")
                for eski_urun in raftaki_eski_urunler:
                    cs_eski = CentralStock.query.get(eski_urun.urun_barkodu)
                    if cs_eski and cs_eski.qty is not None:
                        eski_qty = cs_eski.qty
                        cs_eski.qty = max(0, cs_eski.qty - eski_urun.adet)
                        logger.info(f"   - {eski_urun.urun_barkodu}: {eski_qty} ‚Üí {cs_eski.qty} (D√º≈ü√ºlen: -{eski_urun.adet})")
                
                # 3. Raftaki t√ºm eski kayƒ±tlarƒ± tek seferde sil
                if raftaki_eski_urunler:
                    silinen_sayisi = RafUrun.query.filter_by(raf_kodu=raf_kodu).delete()
                    logger.info(f"üóëÔ∏è '{raf_kodu}' rafƒ±ndan {silinen_sayisi} kayƒ±t silindi.")

            # --- YENƒ∞ √úR√úNLERƒ∞ ƒ∞≈ûLEME (HEM 'ADD' HEM DE 'RENEW' ƒ∞√áƒ∞N) ---
            logger.info(f"‚ûï '{raf_kodu}' rafƒ±na eklenecek √ºr√ºn sayƒ±sƒ±: {len(items)}")
            for it in items:
                barcode = (it.get('barcode') or '').strip()
                try:
                    count = int(it.get('count', 0))
                except (TypeError, ValueError):
                    count = 0

                if not barcode or count < 0:
                    logger.warning(f"Ge√ßersiz barkod veya adet: barkod={barcode}, count={count}")
                    errors[barcode or 'EMPTY'] = "Ge√ßersiz barkod/adet"
                    continue
                if not valid_products.get(barcode.lower()):
                    logger.warning(f"√úr√ºn veritabanƒ±nda bulunamadƒ±: {barcode}")
                    errors[barcode] = "√úr√ºn veritabanƒ±nda yok"
                    continue
                
                # CentralStock kaydƒ±nƒ± bul veya olu≈ütur
                cs = CentralStock.query.get(barcode)
                if not cs:
                    cs = CentralStock(barcode=barcode, qty=0)
                    db.session.add(cs)
                    logger.info(f"Yeni CentralStock kaydƒ± olu≈üturuldu: {barcode}")
                
                # RafUrun kaydƒ±nƒ± bul veya olu≈ütur
                rec = RafUrun.query.filter_by(raf_kodu=raf_kodu, urun_barkodu=barcode).first()
                
                # 'add' ise adedi ekle, 'renew' ise zaten silindiƒüi i√ßin sƒ±fƒ±rdan olu≈ütur
                if rec:
                    eski_adet = rec.adet
                    rec.adet = (rec.adet or 0) + count
                    logger.info(f"Raf: {raf_kodu}, Barkod: {barcode}, Eski: {eski_adet}, Yeni: {rec.adet}")
                else:
                    rec = RafUrun(raf_kodu=raf_kodu, urun_barkodu=barcode, adet=count)
                    db.session.add(rec)
                    logger.info(f"Raf: {raf_kodu}, Barkod: {barcode}, ƒ∞lk kez eklendi, Adet: {count}")
                
                # Merkezi stoƒüu G√úNCEL adede g√∂re artƒ±r
                cs.qty = (cs.qty or 0) + count

                results.append({"barcode": barcode, "central_qty": int(cs.qty or 0)})

            # Transaction ba≈üarƒ±yla tamamlandƒ±
            logger.info(f"‚úÖ Transaction ba≈üarƒ±yla tamamlandƒ± - {len(results)} √ºr√ºn i≈ülendi, {len(errors)} hata.")

        # --- SONU√áLARI D√ñND√úR ---
        if errors:
            logger.warning(f"‚ö†Ô∏è '{raf_kodu}' rafƒ± g√ºncellenirken bazƒ± √ºr√ºnler eklenemedi:")
            for err_barcode, err_msg in list(errors.items())[:10]:  # ƒ∞lk 10 hatayƒ± logla
                logger.warning(f"   - {err_barcode}: {err_msg}")
            if len(errors) > 10:
                logger.warning(f"   ... ve {len(errors) - 10} hata daha.")
            
            return jsonify(success=False,
                           message="Bazƒ± kalemler i≈ülenemedi.",
                           errors=errors,
                           results=results), 207

        message = f"'{raf_kodu}' rafƒ±ndaki {len(results)} √ºr√ºn ba≈üarƒ±yla g√ºncellendi."
        if update_type == 'renew' and not items:
            message = f"'{raf_kodu}' rafƒ± ba≈üarƒ±yla bo≈üaltƒ±ldƒ±."
        
        logger.info(f"üéâ '{raf_kodu}' rafƒ± ba≈üarƒ±yla g√ºncellendi. Toplam {len(results)} √ºr√ºn i≈ülendi. (Mod: {update_type})")

        return jsonify(success=True,
                       message=message,
                       results=results)

    except Exception as e:
        logger.error(f"‚ùå HATA - Raf: {raf_kodu}, Mod: {update_type}, √úr√ºn Sayƒ±sƒ±: {len(items)}")
        logger.error("Stok ekleme/g√ºncelleme hatasƒ±: %s", e, exc_info=True)
        return jsonify(success=False, message=f"Sunucu hatasƒ±: {str(e)}"), 500